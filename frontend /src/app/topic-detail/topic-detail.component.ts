import { Component, signal } from '@angular/core';
import { Subject, Topic, TutoringSession } from '../shared/topic';
import { ActivatedRoute, RouterLink } from '@angular/router';
import { TutorService } from '../shared/tutor.service';
import { DatePipe } from '@angular/common';
import { ToastrService } from 'ngx-toastr';
import { AuthenticationService } from '../shared/authentication.service';

import {
  AbstractControl,
  FormControl,
  FormGroup,
  FormsModule,
  ReactiveFormsModule,
  ValidationErrors,
  Validators,
} from '@angular/forms';
import { RequestSessionFormErrorMessages } from './session-request-form-error-messages';

@Component({
  selector: 'bs-topic-detail',
  standalone: true,
  imports: [DatePipe, FormsModule, ReactiveFormsModule],
  templateUrl: './topic-detail.component.html',
  styles: ``,
})
export class TopicDetailComponent {
  topic = signal<Topic | undefined>(undefined);
  errors: { [key: string]: string } = {};

  subjectId!: number;
  topicId!: number;

  user!: { id: number; first_name: string; role: string };

  currentDate = new Date();

  requestForm: FormGroup;

  constructor(
    private authService: AuthenticationService,
    private tutorService: TutorService,
    private route: ActivatedRoute,
    private toastr: ToastrService,
  ) {
    this.requestForm = new FormGroup({});
  }

  ngOnInit(): void {
    this.subjectId = Number(this.route.snapshot.paramMap.get('id'));
    this.topicId = Number(this.route.snapshot.paramMap.get('topicId'));
    this.user = this.authService.getCurrentUser();
    this.tutorService
      .getSingleTopic(this.subjectId, this.topicId)
      .subscribe((t: Topic) => {
        this.topic.set(t);
      });
    this.requestForm = this.createRequestForm();
    this.requestForm.statusChanges.subscribe(() => this.updateErrorMessages());
  }

  /**
   * Creates a new request form for booking a tutoring session.
   * The form includes fields for comment, topic_id, start_time, and end_time.
   * It also includes validators to ensure the start time is in the future and that the end time is after the start time.
   */
  createRequestForm(): FormGroup {
    return new FormGroup(
      {
        comment: new FormControl('', [Validators.required]),
        topic_id: new FormControl(this.topicId),
        start_time: new FormControl('', [
          Validators.required,
          this.checkDateFuture,
        ]),
        end_time: new FormControl('', [Validators.required]),
      },
      { validators: [this.dateOrderValidator] },
    );
  }

  /**
   * Method to book a tutoring session as a user
   *and to reload the topic*/
  bookSession(sessionId: number) {
    this.tutorService.bookSession(sessionId).subscribe(() => {
      this.toastr.success(
        'Super du hast eine Nachhilfestunde gebucht!',
        'Success',
      );
      this.tutorService
        .getSingleTopic(this.subjectId, this.topicId)
        .subscribe((t: Topic) => {
          this.topic.set(t);
        });
    });
  }

  /**
   * Function generated by ChatGPT
   * Filters tutoring sessions by status and date.
   * Sorts the sessions by start time in ascending order.
   */
  filterSessionsByDate(sessions?: TutoringSession[]): TutoringSession[] {
    return (sessions ?? [])
      .filter(
        (s) =>
          s.status === 'offering' &&
          new Date(s.start_time.replace(' ', 'T')) > this.currentDate,
      )
      .sort(
        (a, b) =>
          new Date(a.start_time.replace(' ', 'T')).getTime() -
          new Date(b.start_time.replace(' ', 'T')).getTime(),
      );
  }

  isLoggedIn() {
    return this.authService.isLoggedIn();
  }

  /**
   * generated by ChatGPT
   * Validates that the end time is after the start time
   * AbstractControl is the base class for FormControl, FormGroup, and FormArray
   * providing shared properties (e.g., value, valid) and methods (e.g., get()).*/
  checkDateFuture(control: AbstractControl): ValidationErrors | null {
    const start = control.value;
    if (start) {
      return new Date(start) < new Date() ? { startTimeInPast: true } : null;
    }
    return null;
  }

  /**
   * gererated by ChatGPT
   * Validates that the end time is after the start time.
   */
  dateOrderValidator(ctrl: AbstractControl): ValidationErrors | null {
    const start = ctrl.get('start_time')!.value;
    const end = ctrl.get('end_time')!.value;
    return start && end && new Date(end) <= new Date(start)
      ? { dateOrder: true }
      : null;
  }

  /**
   * Updates the error messages for the request form based on validation errors.
   * It checks each control in the form and sets the corresponding error message
   * if the control is dirty, invalid, and has a specific validation error.
   */
  updateErrorMessages() {
    this.errors = {};
    for (const message of RequestSessionFormErrorMessages) {
      const control = this.requestForm.get(message.forControl);
      if (
        control &&
        control.dirty &&
        control.invalid &&
        control.errors &&
        control.errors[message.forValidator] &&
        !control.errors[message.forControl]
      ) {
        this.errors[message.forControl] = message.text;
      }
    }

    if (this.requestForm.errors?.['endTimeBeforeStartTime']) {
      this.errors['end_time'] = RequestSessionFormErrorMessages.find(
        (msg) =>
          msg.forControl === 'end_time' &&
          msg.forValidator === 'endTimeBeforeStartTime',
      )!.text;
    }
  }

  submitForm() {
    this.updateErrorMessages();
    if (this.requestForm.valid) {
      this.tutorService
        .requestSession(this.requestForm.value)
        .subscribe((res) => {
          this.toastr.success(
            'Deine Anfrage wurde erfolgreich gesendet!',
            'Success',
          );
          this.requestForm = this.createRequestForm();
        });
    }
  }
}
